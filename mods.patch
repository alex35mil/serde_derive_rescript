diff -ruN /tmp/serde_upstream/serde_derive/src/de/enum_.rs /Users/Alex/Dev/serde_derive_rescript/src/de/enum_.rs
--- /tmp/serde_upstream/serde_derive/src/de/enum_.rs	2025-12-23 21:38:51
+++ /Users/Alex/Dev/serde_derive_rescript/src/de/enum_.rs	2025-12-23 21:01:16
@@ -1,13 +1,15 @@
 use crate::de::enum_adjacently;
 use crate::de::enum_externally;
 use crate::de::enum_internally;
+use crate::de::enum_mixed;
 use crate::de::enum_untagged;
 use crate::de::identifier;
 use crate::de::{field_i, FieldWithAliases, Parameters};
 use crate::fragment::{Expr, Fragment, Stmts};
-use crate::internals::ast::Variant;
+use crate::internals::ast::{Style, Variant};
 use crate::internals::attr;
 use crate::private;
+use crate::rescript;
 use proc_macro2::TokenStream;
 use quote::quote;

@@ -41,10 +43,28 @@
     variants: &[Variant],
     cattrs: &attr::Container,
 ) -> Fragment {
+    // ReScript: detect mixed enums (both unit and struct variants)
+    let is_mixed = rescript::is_mixed_enum(variants);
+
     match cattrs.tag() {
-        attr::TagType::External => enum_externally::deserialize(params, variants, cattrs),
+        attr::TagType::External => {
+            // ReScript: handle mixed and struct-only enums specially
+            if is_mixed {
+                enum_mixed::deserialize(params, variants, cattrs)
+            } else if variants.iter().any(|v| matches!(v.style, Style::Struct)) {
+                // Non-mixed struct variants use internal tagging with TAG
+                let tag = rescript::get_effective_tag(cattrs);
+                enum_internally::deserialize(params, variants, cattrs, &tag)
+            } else {
+                enum_externally::deserialize(params, variants, cattrs)
+            }
+        }
         attr::TagType::Internal { tag } => {
-            enum_internally::deserialize(params, variants, cattrs, tag)
+            if is_mixed {
+                enum_mixed::deserialize(params, variants, cattrs)
+            } else {
+                enum_internally::deserialize(params, variants, cattrs, tag)
+            }
         }
         attr::TagType::Adjacent { tag, content } => {
             enum_adjacently::deserialize(params, variants, cattrs, tag, content)
diff -ruN /tmp/serde_upstream/serde_derive/src/de/enum_mixed.rs /Users/Alex/Dev/serde_derive_rescript/src/de/enum_mixed.rs
--- /tmp/serde_upstream/serde_derive/src/de/enum_mixed.rs	1970-01-01 03:00:00
+++ /Users/Alex/Dev/serde_derive_rescript/src/de/enum_mixed.rs	2025-12-23 21:25:37
@@ -0,0 +1,246 @@
+//! Deserialization for ReScript-style mixed enums (unit + struct variants).
+//!
+//! Mixed enums are deserialized as:
+//! - Unit variants: plain strings like `"VariantName"`
+//! - Struct variants: objects with TAG field like `{ "TAG": "VariantName", "field": value }`
+
+use crate::de::struct_;
+use crate::de::{field_i, Parameters, StructForm};
+use crate::fragment::{Fragment, Match};
+use crate::internals::ast::{Style, Variant};
+use crate::internals::attr;
+use crate::private;
+use crate::rescript;
+use quote::quote;
+
+/// Generates `Deserialize::deserialize` body for a mixed enum (unit + struct variants)
+pub(super) fn deserialize(
+    params: &Parameters,
+    variants: &[Variant],
+    cattrs: &attr::Container,
+) -> Fragment {
+    let this_type = &params.this_type;
+    let this_value = &params.this_value;
+    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) =
+        params.generics_with_de_lifetime();
+    let delife = params.borrowed.de_lifetime();
+
+    let expecting = format!("mixed enum {}", params.type_name());
+    let expecting = cattrs.expecting().unwrap_or(&expecting);
+
+    let tag = rescript::get_effective_tag(cattrs);
+
+    // Unit variants - deserialize from strings
+    let unit_variants: Vec<_> = variants
+        .iter()
+        .enumerate()
+        .filter(|(_, v)| !v.attrs.skip_deserializing() && matches!(v.style, Style::Unit))
+        .collect();
+
+    let unit_variant_arms: Vec<_> = unit_variants
+        .iter()
+        .map(|(_, variant)| {
+            let variant_name = variant.attrs.name().deserialize_name();
+            let variant_ident = &variant.ident;
+            quote! {
+                #variant_name => _serde::#private::Ok(#this_value::#variant_ident),
+            }
+        })
+        .collect();
+
+    let unit_variant_names: Vec<_> = unit_variants
+        .iter()
+        .map(|(_, v)| v.attrs.name().deserialize_name())
+        .collect();
+
+    // Struct variants
+    let struct_variants: Vec<_> = variants
+        .iter()
+        .enumerate()
+        .filter(|(_, v)| !v.attrs.skip_deserializing() && matches!(v.style, Style::Struct))
+        .collect();
+
+    // Generate variant enum for struct variants
+    let struct_variant_field_idents: Vec<_> =
+        struct_variants.iter().map(|(i, _)| field_i(*i)).collect();
+
+    let struct_variant_names: Vec<_> = struct_variants
+        .iter()
+        .map(|(_, v)| v.attrs.name().deserialize_name())
+        .collect();
+
+    // Build variant enum match arms
+    let variant_match_arms: Vec<_> = struct_variants
+        .iter()
+        .map(|(i, v)| {
+            let name = v.attrs.name().deserialize_name();
+            let ident = field_i(*i);
+            quote! { #name => _serde::#private::Ok(__Field::#ident) }
+        })
+        .collect();
+
+    // Generate variant enum for struct variants (used to deserialize the TAG value)
+    let field_enum = if struct_variants.is_empty() {
+        quote! {}
+    } else {
+        quote! {
+            #[doc(hidden)]
+            enum __Field {
+                #(#struct_variant_field_idents,)*
+            }
+
+            impl<#delife> _serde::Deserialize<#delife> for __Field {
+                fn deserialize<__D>(__deserializer: __D) -> _serde::#private::Result<Self, __D::Error>
+                where
+                    __D: _serde::Deserializer<#delife>,
+                {
+                    struct __FieldVisitor;
+
+                    impl<#delife> _serde::de::Visitor<#delife> for __FieldVisitor {
+                        type Value = __Field;
+
+                        fn expecting(&self, __f: &mut _serde::#private::Formatter) -> _serde::#private::fmt::Result {
+                            _serde::#private::Formatter::write_str(__f, "variant identifier")
+                        }
+
+                        fn visit_str<__E>(self, __value: &str) -> _serde::#private::Result<Self::Value, __E>
+                        where
+                            __E: _serde::de::Error,
+                        {
+                            match __value {
+                                #(#variant_match_arms,)*
+                                _ => _serde::#private::Err(_serde::de::Error::unknown_variant(__value, &[#(#struct_variant_names),*])),
+                            }
+                        }
+                    }
+
+                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
+                }
+            }
+        }
+    };
+
+    // Generate match arms for struct variants using struct_::deserialize
+    let struct_variant_arms: Vec<_> = struct_variants
+        .iter()
+        .map(|(i, variant)| {
+            let variant_field = field_i(*i);
+            let variant_ident = &variant.ident;
+
+            let block = Match(struct_::deserialize(
+                params,
+                &variant.fields,
+                cattrs,
+                StructForm::InternallyTagged(variant_ident),
+            ));
+
+            quote! {
+                __Field::#variant_field => #block
+            }
+        })
+        .collect();
+
+    // For unit variants from string
+    let visit_str_body = if unit_variants.is_empty() {
+        quote! {
+            _serde::#private::Err(_serde::de::Error::custom("expected object with TAG field"))
+        }
+    } else {
+        quote! {
+            match __value {
+                #(#unit_variant_arms)*
+                _ => {
+                    let __expected = &[#(#unit_variant_names),*];
+                    _serde::#private::Err(_serde::de::Error::unknown_variant(__value, __expected))
+                }
+            }
+        }
+    };
+
+    // For struct variants from map: use TaggedContentVisitor pattern
+    let visit_map_body = if struct_variants.is_empty() {
+        quote! {
+            _serde::#private::Err(_serde::de::Error::custom("expected string for unit variant"))
+        }
+    } else {
+        quote! {
+            // Collect entries and extract TAG field (similar to TaggedContentVisitor)
+            let mut __tag: _serde::#private::Option<__Field> = _serde::#private::None;
+            let mut __vec = _serde::#private::Vec::<(
+                _serde::#private::de::Content<#delife>,
+                _serde::#private::de::Content<#delife>,
+            )>::new();
+
+            while let _serde::#private::Some(__key) = _serde::de::MapAccess::next_key_seed(&mut __map, _serde::#private::de::ContentVisitor::new())? {
+                // Check if this key matches the tag field
+                let __is_tag = match &__key {
+                    _serde::#private::de::Content::String(__s) => __s == #tag,
+                    _serde::#private::de::Content::Str(__s) => *__s == #tag,
+                    _ => false,
+                };
+                if __is_tag {
+                    if __tag.is_some() {
+                        return _serde::#private::Err(_serde::de::Error::duplicate_field(#tag));
+                    }
+                    __tag = _serde::#private::Some(_serde::de::MapAccess::next_value(&mut __map)?);
+                } else {
+                    let __v = _serde::de::MapAccess::next_value_seed(&mut __map, _serde::#private::de::ContentVisitor::new())?;
+                    __vec.push((__key, __v));
+                }
+            }
+
+            let __tag = match __tag {
+                _serde::#private::Some(__t) => __t,
+                _serde::#private::None => return _serde::#private::Err(_serde::de::Error::missing_field(#tag)),
+            };
+
+            // Create ContentDeserializer from the remaining fields
+            let __content = _serde::#private::de::Content::Map(__vec);
+            let __deserializer = _serde::#private::de::ContentDeserializer::<__A::Error>::new(__content);
+
+            match __tag {
+                #(#struct_variant_arms)*
+            }
+        }
+    };
+
+    quote_block! {
+        #field_enum
+
+        #[doc(hidden)]
+        struct __Visitor #de_impl_generics #where_clause {
+            marker: _serde::#private::PhantomData<#this_type #ty_generics>,
+            lifetime: _serde::#private::PhantomData<&#delife ()>,
+        }
+
+        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {
+            type Value = #this_type #ty_generics;
+
+            fn expecting(&self, __formatter: &mut _serde::#private::Formatter) -> _serde::#private::fmt::Result {
+                _serde::#private::Formatter::write_str(__formatter, #expecting)
+            }
+
+            fn visit_str<__E>(self, __value: &str) -> _serde::#private::Result<Self::Value, __E>
+            where
+                __E: _serde::de::Error,
+            {
+                #visit_str_body
+            }
+
+            fn visit_map<__A>(self, mut __map: __A) -> _serde::#private::Result<Self::Value, __A::Error>
+            where
+                __A: _serde::de::MapAccess<#delife>,
+            {
+                #visit_map_body
+            }
+        }
+
+        _serde::Deserializer::deserialize_any(
+            __deserializer,
+            __Visitor {
+                marker: _serde::#private::PhantomData::<#this_type #ty_generics>,
+                lifetime: _serde::#private::PhantomData,
+            },
+        )
+    }
+}
diff -ruN /tmp/serde_upstream/serde_derive/src/de.rs /Users/Alex/Dev/serde_derive_rescript/src/de.rs
--- /tmp/serde_upstream/serde_derive/src/de.rs	2025-12-23 21:38:51
+++ /Users/Alex/Dev/serde_derive_rescript/src/de.rs	2025-12-23 21:00:49
@@ -16,6 +16,7 @@
 mod enum_adjacently;
 mod enum_externally;
 mod enum_internally;
+mod enum_mixed;
 mod enum_untagged;
 mod identifier;
 mod struct_;
diff -ruN /tmp/serde_upstream/serde_derive/src/internals/attr.rs /Users/Alex/Dev/serde_derive_rescript/src/internals/attr.rs
--- /tmp/serde_upstream/serde_derive/src/internals/attr.rs	2025-12-23 21:38:51
+++ /Users/Alex/Dev/serde_derive_rescript/src/internals/attr.rs	2025-12-23 21:25:45
@@ -516,18 +516,29 @@
             }
         }

+        // ReScript modification: default to camelCase for struct fields
+        let default_rename_all_rule = match &item.data {
+            syn::Data::Struct(_) => RenameRule::CamelCase,
+            syn::Data::Enum(_) => RenameRule::None,
+            syn::Data::Union(_) => RenameRule::None,
+        };
+
         Container {
             name: MultiName::from_attrs(Name::from(&unraw(&item.ident)), ser_name, de_name, None),
             transparent: transparent.get(),
             deny_unknown_fields: deny_unknown_fields.get(),
             default: default.get().unwrap_or(Default::None),
             rename_all_rules: RenameAllRules {
-                serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),
-                deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),
+                serialize: rename_all_ser_rule.get().unwrap_or(default_rename_all_rule),
+                deserialize: rename_all_de_rule.get().unwrap_or(default_rename_all_rule),
             },
             rename_all_fields_rules: RenameAllRules {
-                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),
-                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),
+                serialize: rename_all_fields_ser_rule
+                    .get()
+                    .unwrap_or(RenameRule::CamelCase),
+                deserialize: rename_all_fields_de_rule
+                    .get()
+                    .unwrap_or(RenameRule::CamelCase),
             },
             ser_bound: ser_bound.get(),
             de_bound: de_bound.get(),
diff -ruN /tmp/serde_upstream/serde_derive/src/lib.rs /Users/Alex/Dev/serde_derive_rescript/src/lib.rs
--- /tmp/serde_upstream/serde_derive/src/lib.rs	2025-12-23 21:38:51
+++ /Users/Alex/Dev/serde_derive_rescript/src/lib.rs	2025-12-23 22:26:16
@@ -1,17 +1,13 @@
-//! This crate provides Serde's two derive macros.
+//! This crate provides ReScript-compatible derive macros for serde.
 //!
 //! ```edition2021
-//! # use serde_derive::{Deserialize, Serialize};
+//! # use serde_derive_rescript::{DeserializeDto, SerializeDto};
 //! #
-//! #[derive(Serialize, Deserialize)]
+//! #[derive(SerializeDto, DeserializeDto)]
 //! # struct S;
 //! #
 //! # fn main() {}
 //! ```
-//!
-//! Please refer to [https://serde.rs/derive.html] for how to set this up.
-//!
-//! [https://serde.rs/derive.html]: https://serde.rs/derive.html

 #![doc(html_root_url = "https://docs.rs/serde_derive/1.0.228")]
 #![cfg_attr(not(check_cfg), allow(unexpected_cfgs))]
@@ -89,9 +85,12 @@
 mod deprecated;
 mod dummy;
 mod pretend;
+mod rescript;
 mod ser;
 mod this;

+// Serde 1.0.X exports __privateX where X is the patch version.
+// Our crate version matches serde's, so we use CARGO_PKG_VERSION_PATCH.
 #[allow(non_camel_case_types)]
 struct private;

@@ -110,7 +109,7 @@
     }
 }

-#[proc_macro_derive(Serialize, attributes(serde))]
+#[proc_macro_derive(SerializeDto, attributes(serde))]
 pub fn derive_serialize(input: TokenStream) -> TokenStream {
     let mut input = parse_macro_input!(input as DeriveInput);
     ser::expand_derive_serialize(&mut input)
@@ -118,7 +117,7 @@
         .into()
 }

-#[proc_macro_derive(Deserialize, attributes(serde))]
+#[proc_macro_derive(DeserializeDto, attributes(serde))]
 pub fn derive_deserialize(input: TokenStream) -> TokenStream {
     let mut input = parse_macro_input!(input as DeriveInput);
     de::expand_derive_deserialize(&mut input)
diff -ruN /tmp/serde_upstream/serde_derive/src/rescript.rs /Users/Alex/Dev/serde_derive_rescript/src/rescript.rs
--- /tmp/serde_upstream/serde_derive/src/rescript.rs	1970-01-01 03:00:00
+++ /Users/Alex/Dev/serde_derive_rescript/src/rescript.rs	2025-12-23 20:55:39
@@ -0,0 +1,27 @@
+//! Utilities for handling enums with ReScript-style serialization.
+
+use crate::internals::ast::{Style, Variant};
+use crate::internals::attr;
+
+/// Default tag field name for internally tagged struct variants in enums - matches ReSript one.
+pub const DEFAULT_TAG: &str = "TAG";
+
+/// Determines if an enum is "mixed" - containing both unit and struct variants.
+///
+/// Mixed enums receive special serialization/deserialization treatment:
+/// - Unit variants are serialized as strings
+/// - Struct variants are serialized with internal tagging
+pub fn is_mixed_enum(variants: &[Variant]) -> bool {
+    let has_unit = variants.iter().any(|v| matches!(v.style, Style::Unit));
+    let has_struct = variants.iter().any(|v| matches!(v.style, Style::Struct));
+    has_unit && has_struct
+}
+
+/// Gets the effective tag name for enum, respecting explicit `#[serde(tag = "...")]`
+/// attributes but defaulting to `DEFAULT_TAG` if none is specified.
+pub fn get_effective_tag(cattrs: &attr::Container) -> String {
+    match cattrs.tag() {
+        attr::TagType::Internal { tag } => tag.clone(),
+        _ => DEFAULT_TAG.to_string(),
+    }
+}
diff -ruN /tmp/serde_upstream/serde_derive/src/ser.rs /Users/Alex/Dev/serde_derive_rescript/src/ser.rs
--- /tmp/serde_upstream/serde_derive/src/ser.rs	2025-12-23 21:38:51
+++ /Users/Alex/Dev/serde_derive_rescript/src/ser.rs	2025-12-23 21:25:45
@@ -3,7 +3,7 @@
 use crate::internals::ast::{Container, Data, Field, Style, Variant};
 use crate::internals::name::Name;
 use crate::internals::{attr, replace_receiver, Ctxt, Derive};
-use crate::{bound, dummy, pretend, private, this};
+use crate::{bound, dummy, pretend, private, rescript, this};
 use proc_macro2::{Span, TokenStream};
 use quote::{quote, quote_spanned};
 use syn::spanned::Spanned;
@@ -394,13 +394,16 @@
 fn serialize_enum(params: &Parameters, variants: &[Variant], cattrs: &attr::Container) -> Fragment {
     assert!(variants.len() as u64 <= u64::from(u32::MAX));

+    // ReScript: detect mixed enums (both unit and struct variants)
+    let is_mixed = rescript::is_mixed_enum(variants);
+
     let self_var = &params.self_var;

     let mut arms: Vec<_> = variants
         .iter()
         .enumerate()
         .map(|(variant_index, variant)| {
-            serialize_variant(params, variant, variant_index as u32, cattrs)
+            serialize_variant(params, variant, variant_index as u32, cattrs, is_mixed)
         })
         .collect();

@@ -422,6 +425,7 @@
     variant: &Variant,
     variant_index: u32,
     cattrs: &attr::Container,
+    is_mixed_enum: bool,
 ) -> TokenStream {
     let this_value = &params.this_value;
     let variant_ident = &variant.ident;
@@ -473,10 +477,49 @@

         let body = Match(match (cattrs.tag(), variant.attrs.untagged()) {
             (attr::TagType::External, false) => {
-                serialize_externally_tagged_variant(params, variant, variant_index, cattrs)
+                // ReScript: handle mixed enums and struct-only enums specially
+                if is_mixed_enum {
+                    match variant.style {
+                        Style::Unit => {
+                            // Unit variants in mixed enums serialize as strings
+                            let variant_name = variant.attrs.name().serialize_name();
+                            quote_expr! {
+                                _serde::Serializer::serialize_str(__serializer, #variant_name)
+                            }
+                        }
+                        Style::Struct => {
+                            // Struct variants in mixed enums use internal tagging with TAG
+                            let tag = rescript::get_effective_tag(cattrs);
+                            serialize_internally_tagged_variant(params, variant, cattrs, &tag)
+                        }
+                        _ => {
+                            // Newtype/Tuple: fall back to external tagging
+                            serialize_externally_tagged_variant(
+                                params,
+                                variant,
+                                variant_index,
+                                cattrs,
+                            )
+                        }
+                    }
+                } else if matches!(variant.style, Style::Struct) {
+                    // Non-mixed struct variants also use internal tagging with TAG
+                    let tag = rescript::get_effective_tag(cattrs);
+                    serialize_internally_tagged_variant(params, variant, cattrs, &tag)
+                } else {
+                    serialize_externally_tagged_variant(params, variant, variant_index, cattrs)
+                }
             }
             (attr::TagType::Internal { tag }, false) => {
-                serialize_internally_tagged_variant(params, variant, cattrs, tag)
+                // ReScript: in mixed enums, unit variants serialize as plain strings
+                if is_mixed_enum && matches!(variant.style, Style::Unit) {
+                    let variant_name = variant.attrs.name().serialize_name();
+                    quote_expr! {
+                        _serde::Serializer::serialize_str(__serializer, #variant_name)
+                    }
+                } else {
+                    serialize_internally_tagged_variant(params, variant, cattrs, tag)
+                }
             }
             (attr::TagType::Adjacent { tag, content }, false) => {
                 serialize_adjacently_tagged_variant(
